package gen_go

import (
	"encoding/json"
	"fmt"
	"io"
	"os"
	"os/exec"
	"strings"
	"text/template"

	goadl "github.com/adl-lang/goadl_rt"
	"github.com/golang/glog"
	"github.com/jpillora/opts"
)

func NewGenGo() opts.Opts {
	wk, err := os.MkdirTemp("", "goadlc-")
	if err != nil {
		glog.Warningf(`os.MkdirTemp("", "goadlc-") %v`, err)
	}
	cwd, err := os.Getwd()
	if err != nil {
		glog.Warningf(`error getting current working directory %v`, err)
	}
	return opts.New(&gengoCmd{
		WorkingDir: wk,
		Outputdir:  cwd,
	})
}

type gengoCmd struct {
	WorkingDir  string
	Searchdir   []string `opts:"short=I" help:"Add the specifed directory to the ADL searchpath"`
	Outputdir   string   `opts:"short=O" help:"Set the directory where generated code is written "`
	MergeAdlext string   `help:"Add the specifed adl file extension to merged on loading"`
	Debug       bool     `help:"Print extra diagnostic information, especially about files being read/written"`
	NoGoFmt     bool     `help:"Don't run 'go fmt' on the generated files"`
	// NoOverwrite    bool     `help:"Don't update files that haven't changed"`
	// Manifest       string   `help:"Write a manifest file recording generated files"`
	// CombinedOutput string   `help:"The json file to which all adl modules will be written"`
	Files []string `opts:"mode=arg"`
}

func (in *gengoCmd) workingDir() string  { return in.WorkingDir }
func (in *gengoCmd) searchdir() []string { return in.Searchdir }
func (in *gengoCmd) mergeAdlext() string { return in.MergeAdlext }
func (in *gengoCmd) debug() bool         { return in.Debug }
func (in *gengoCmd) files() []string     { return in.Files }

func (in *gengoCmd) Run() error {
	if len(in.Files) == 0 {
		return fmt.Errorf("no files specified")
	}
	jb := func(fd io.Reader) (moduleMap[goadl.Module], moduleMap[goadl.Decl], error) {
		combinedAst := make(moduleMap[goadl.Module])
		declMap := make(moduleMap[goadl.Decl])
		dec := json.NewDecoder(fd)
		err := dec.Decode(&combinedAst)
		if err != nil {
			return nil, nil, err
		}
		for k, v := range combinedAst {
			for dk, dv := range v.Decls {
				declMap[k+"::"+dk] = dv
			}
		}
		return combinedAst, declMap, nil
	}
	modules := []moduleTuple[goadl.Module]{}
	combinedAst, declMap, err := loadAdl(in, &modules, jb)
	_ = combinedAst
	_ = declMap
	if err != nil {
		return err
	}
	// fmt.Printf("cli modules\n")
	for _, m := range modules {
		modCodeGen := ModuleCodeGen{}
		modCodeGen.Directory = strings.Split(m.name, ".")
		path := in.Outputdir + "/" + strings.Join(modCodeGen.Directory, "/")
		if _, err = os.Open(path); err != nil {
			err = os.MkdirAll(path, os.ModePerm)
			if err != nil {
				glog.Fatalf("mkdir -p %s, error: %v", path, err)
			}
		}
		// fmt.Printf("  annotation %v\n", m.module.Annotations)
		for name, decl := range m.module.Decls {
			fname := path + "/" + name + ".go"
			generalDecl(fname, path, name, modCodeGen, decl, m.name)
			if !in.NoGoFmt {
				out, err := exec.Command("go", "fmt", fname).CombinedOutput()
				if err != nil {
					glog.Fatalf("go fmt error err : %v output '%s'", err, string(out))
				}
			}
		}
	}
	// fmt.Printf("all modules\n")
	// for k := range allModules {
	// 	fmt.Printf(" %s\n", k)
	// }
	return nil
}

var (
	headerTmpl = template.Must(template.New("header").Parse(`// Code generated by goadlc v1 - DO NOT EDIT.
package {{.Pkg}}

`))
	importsTmpl = template.Must(template.New("imports").Parse(`import (
	"{{.Rt}}"{{range .Imports}}
	"{{.}}"{{end}}
)

`))
)

func generalDecl(fname string, path string, name string, modCodeGen ModuleCodeGen, decl goadl.Decl, moduleName string) {
	var fd *os.File = nil
	var err error
	fd, err = os.OpenFile(fname, os.O_RDWR|os.O_CREATE|os.O_TRUNC, os.ModePerm)
	// fd.Truncate(0)
	// fd.Seek(0, 0)
	defer func() {
		fd.Sync()
		fd.Close()
	}()
	if err != nil {
		glog.Fatalf("open %s, error: %v", path, err)
	}

	render := templateRenderer{t: templates}
	render.Render(headerParams{Pkg: modCodeGen.Directory[len(modCodeGen.Directory)-1]})
	render.Render(importsParams{
		Rt:      "github.com/adl-lang/goadl_rt",
		Imports: []string{},
	})
	fd.Write(render.Bytes())

	// headerTmpl.Execute(fd, struct{ Pkg string }{Pkg: modCodeGen.Directory[len(modCodeGen.Directory)-1]})
	// importsTmpl.Execute(fd, struct {
	// 	Rt      string
	// 	Imports []string
	// }{Rt: "github.com/adl-lang/goadl_rt", Imports: []string{}})

	fmt.Fprintf(fd, "type %s struct {\n", name)
	// declBy, _ := json.Marshal(decl)
	// fmt.Printf("  json %s\n", string(declBy))
	if decl.Type.Struct != nil {
		for _, fld := range decl.Type.Struct.Field {
			if fld.TypeExpr.TypeRef.Primitive != nil {
				_type := goadl.PrimitiveMap[*fld.TypeExpr.TypeRef.Primitive]
				fmt.Fprintf(fd, "	%[2]s %[3]s `json:\"%[1]s\"`\n", fld.Name, strings.ToTitle(fld.Name), _type)
			}
			// fldBy, _ := json.Marshal(fld)
			// fmt.Printf("    json %s\n", string(fldBy))
		}
	}
	fmt.Fprintf(fd, "}\n")

	fmt.Fprintf(fd, `func init() {
	goadl_rt.RESOLVER.Register(
		goadl_rt.ScopedName{
			ModuleName: "%[1]s",
			Name:       "%[2]s",
		},
		func() interface{} {
			return &%[2]s{}
		},
	)
}`, moduleName, name)
}
