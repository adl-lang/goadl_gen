// Code generated by goadlc v3 - DO NOT EDIT.
package gomod

import (
	"fmt"
)

type GoModResult struct {
	_GoModResult
}

type _GoModResult struct {
	ModulePath string `json:"ModulePath"`
	RootDir    string `json:"RootDir"`
}

func MakeAll_GoModResult(
	modulepath string,
	rootdir string,
) GoModResult {
	return GoModResult{
		_GoModResult{
			ModulePath: modulepath,
			RootDir:    rootdir,
		},
	}
}

func Make_GoModResult(
	modulepath string,
	rootdir string,
) GoModResult {
	ret := GoModResult{
		_GoModResult{
			ModulePath: modulepath,
			RootDir:    rootdir,
		},
	}
	return ret
}

type GoModule struct {
	Branch GoModuleBranch
}

type GoModuleBranch interface {
	isGoModuleBranch()
}

func (*GoModule) MakeNewBranch(key string) (any, error) {
	switch key {
	case "ModulePath":
		return &_GoModule_ModulePath{}, nil
	case "GoModFile":
		return &_GoModule_GoModFile{}, nil
	case "Outputdir":
		return &_GoModule_Outputdir{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type _GoModule_ModulePath struct {
	V GoModResult `branch:"ModulePath"`
}
type _GoModule_GoModFile struct {
	V string `branch:"GoModFile"`
}
type _GoModule_Outputdir struct {
	V string `branch:"Outputdir"`
}

func (_GoModule_ModulePath) isGoModuleBranch() {}
func (_GoModule_GoModFile) isGoModuleBranch()  {}
func (_GoModule_Outputdir) isGoModuleBranch()  {}

func Make_GoModule_ModulePath(v GoModResult) GoModule {
	return GoModule{
		_GoModule_ModulePath{v},
	}
}

func Make_GoModule_GoModFile(v string) GoModule {
	return GoModule{
		_GoModule_GoModFile{v},
	}
}

func Make_GoModule_Outputdir(v string) GoModule {
	return GoModule{
		_GoModule_Outputdir{v},
	}
}

func (un GoModule) Cast_ModulePath() (GoModResult, bool) {
	br, ok := un.Branch.(_GoModule_ModulePath)
	return br.V, ok
}

func (un GoModule) Cast_GoModFile() (string, bool) {
	br, ok := un.Branch.(_GoModule_GoModFile)
	return br.V, ok
}

func (un GoModule) Cast_Outputdir() (string, bool) {
	br, ok := un.Branch.(_GoModule_Outputdir)
	return br.V, ok
}

func Handle_GoModule[T any](
	_in GoModule,
	ModulePath func(ModulePath GoModResult) T,
	GoModFile func(GoModFile string) T,
	Outputdir func(Outputdir string) T,
	_default func() T,
) T {
	switch _b := _in.Branch.(type) {
	case _GoModule_ModulePath:
		if ModulePath != nil {
			return ModulePath(_b.V)
		}
	case _GoModule_GoModFile:
		if GoModFile != nil {
			return GoModFile(_b.V)
		}
	case _GoModule_Outputdir:
		if Outputdir != nil {
			return Outputdir(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : GoModule")
}

func HandleWithErr_GoModule[T any](
	_in GoModule,
	ModulePath func(ModulePath GoModResult) (T, error),
	GoModFile func(GoModFile string) (T, error),
	Outputdir func(Outputdir string) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.Branch.(type) {
	case _GoModule_ModulePath:
		if ModulePath != nil {
			return ModulePath(_b.V)
		}
	case _GoModule_GoModFile:
		if GoModFile != nil {
			return GoModFile(_b.V)
		}
	case _GoModule_Outputdir:
		if Outputdir != nil {
			return Outputdir(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : GoModule")
}
